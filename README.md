# Тестовое Задание: Разработка API для Управления Библиотекой

RESTful API для управления библиотечным каталогом.
Система позволяет управлять информацией о книгах, авторах, читателях и
выдавать книги.

<hr>

- [Запуск приложения](#run)
- [Тестирование приложения](#test)
- [Эндпоинты](#endpoints)
- [Описание реализации](#realization)

<hr>


<h2 id="run">Запуск приложения</h2>

1. Склонируйте репозиторий:

```
git clone https://github.com/Tarasyonok/library-api
```

2. Перейди в папку с проектом:

```
cd library-api
```

3. Соберите контейнер:

```
docker compose build
```

4. Запустите контейнер:

```
docker compose up
```

5. Приложение будет запущено на `localhost` на `8000` порту. Для тестирования эндпоитнтов перейдите в
   документацию: http://localhost:8000/docs

<h2 id="test">Тестирование приложения</h2>

1. Клонируем репозиторий:

```
git clone https://github.com/Tarasyonok/library-api
```

2. Переходим в папку с проектом:

```
cd library-api
```

3. Создайте виртуальное окружение:

```
python -m venv venv
```

4. Активируйте виртуальное окружение:

```
./venv/Scripts/activate
```

5. Установите зависимости:

```
pip install -r requirements.txt
```

6. Создайте PostgreSQL базу данных и заполните `.env`.  
   Шаблон находится в файле `.env-example`.

7. Прогоните миграции:

```
alembic upgrade head
```

8. Протестируйте приложение:

```
pytest
```

9. Можно запустить приложение: в режиме разработки:

```
uvicorn app.main:app --reload --port 8000
```

10. Приложение будет запущено на `localhost` на `8000` порту. Для тестирования эндпоитнтов перейдите в
    документацию: http://localhost:8000/docs

<h2 id="endpoints">Эндпоинты</h2>

Эндпоинты приложения с кратким описанием.
Объяснение эндпоинтов помеченных ⭐ находится в [описании реализации](#realization).

### Авторы

- GET /authors/by_id/{id} (Получение автора по ID)
- GET /authors  (Получение всех авторов)
- POST /authors (Добавление автора)⭐
- POST /authors/{id} (Обновление автора)⭐
- DELETE /authors/{id} (Удаление автора)
- GET /authors/filter (Фильтрация & пагинация авторов)⭐

### Книги

- GET /books/by_id/{id} (Получение книги по ID)
- GET /books  (Получение всех книг)
- POST /books (Добавление книги)⭐
- POST /books/{id} (Обновление книги)⭐
- DELETE /books/{id} (Удаление книги)
- GET /books/filter (Фильтрация & пагинация книг)⭐

### Авторизация

- POST /auth/register (Регистрация)⭐
- POST /auth/login (Вход в аккаунт)
- POST /auth/logout (Выход из аккаунта)

### Пользователи

- GET /users/profile/view (Просмотр аккаунта текущего пользователя)
- POST /users/profile/change (Изменение аккаунта текущего пользователя)

Следующие эндпоинты только для админов:

- GET /users/{id} (Получение читателя по ID)
- GET /users  (Получение всех читателей)
- POST /users (Добавление читателя вручную без регистрации)
- POST /users/{id} (Обновление читателя)
- DELETE /users/{id} (Удаление читателя)

### Выдача и возврат книг

- GET /lendings/by_id/{id} (Получение записи о выдачи книги по ID)
- GET /lendings (Получение всех записей о выдачах книг)
- GET /lendings/current_user (Получение записей о выдачах книг текущего пользователя)
- POST /lendings/lend_book (Выдача книги)⭐
- DELETE /lendings/{id} (Возврат книги)⭐
- DELETE /lendings/return_book/{id} (Возврат книги по ID записи для админов)

### Загрузка тестовых данных

- POST /mock_data (Загрузка тестовых данных в бд, сделано для удобства проверки тестового задания)

<h2 id="realization">Описание реализации</h2>

### Общее представление

Сервис разбит на составляющие (авторы, книги, читатели, выдача книг). Для каждой части есть свои роутер, pydantic схемы,
ORM модели и DAO (Data Access Object).

Между таблицами `authors` и `books` реализована связь многие ко многим через промежуточную таблицу `authors_books`.
Также есть связь многие ко многим между `users` и `books`. Я думал о том, чтобы использовать таблицу `users_books` для
связи и выдачи книг, но решил оставить `users_books` только для связи, а для выдачи книг создать таблицу `lendings`.

Все запросы к базе данных сделаны при помощи ORM. Есть базовый DAO в котором прописаны CRUD операции, но у меня не
получилось воспользоваться им в полной мере из-за связей многие ко многим, поэтому пришлось несколько раз писать один и
тот же код для авторов, книг и пользователей.

Авторизация и аутентификация происходит по принципу JWT токенов. Я знаю про 2 типа токенов (Refresh и Access) но в
данном приложении я сделал только access токены.

Я написала 41 тест, которые тестируют DAO и API. Все тесты проходят без ошибок. ✅

Docker compose использует образ PostgreSQL с DockerHub и образ моего приложения который прописан в файле `Dockerfile`.

### Добавление и изменение авторов и книг

При добавлении или изменении автора в списке `books` можно указать ID книг, которые написал этот автор. Так же, при
добавлении книги можно указать ID её авторов в списке `authors`

### Фильтрация авторов и книг

Фильтрация реализована с помощью библиотеки `FastAPI_Filter`. Она работает по принципу pydantic схем.
Поиск по строкам сделан через like, что позволяет искать похожие записи, а не точное совпадение.
В книгах можно делать фильтрацию по жанрам причём указать можно сразу несколько.
Пагинация сделана через `LIMIT`.

### Регистрация

Я не очень хорошо представляю как работает выдачи админки, поэтому моя реализация непрактична.
Роль пользователя указывается при регистрации. В дальнейшем её изменить нельзя. Без регистрации можно смотреть авторов и
книги. Обычный пользователь может просматривать и изменять свой профиль, брать и возвращать книги. У админа есть доступ
ко всем эндпоинтам.

### Выдача и возврат книг

Взять книгу можно по ID.  
В этих двух эндпоинтах я полностью сделал обработку ошибок:  
`ReturnTimeBeforeLendTimeException` - Время выдачи после предполагаемого времени возврата  
`BookNotFoundException` - Указанная книга не найдена  
`UserDoesntExistException` - Не существующий пользователь  
`BookAlreadyLentException` - Пользователь уже взял эту книгу  
`NoBooksLeftException` - Таких книг нет в наличии  
`FiveBooksLentException` - Пользователь уже взял 5 книг

В задании написано:

> Фиксировать дату выдачи и предполагаемую дату возврата.

Не совсем понял про предполагаемую дату возврата, поэтому у меня просто сохраняется две даты при выдаче книги. Возможно
предполагаемая дата может быть нужна при просмотре всех просроченных записей о выдачи книг.

### Загрузка тестовых данных в бд

Загрузка тестовых данных происходит в двух местах - тестирование и на реальной бд для удобства проверки.   
Тестовые данные выгружаются из CSV файлов, которые находятся в папке `mock_data`. PostgreSQL не выгружает данные в json
формате, поэтому пришлось либо работать с CSV, либо вручную заполнить json файлы данными. Я выбрал первый вариант,
поэтому мне пришлось преобразовывать все числовые поля в числа из строк. Также у меня возникла проблема, при которой
после загрузки тестовых данных в бд у меня не обновлялись ID, из-за чего после добавления нового объекта выходила
ошибка, что такой ID уже есть. Я решил эту проблему начиная добавлять все новые записи с ID=101.

## Заключение

❗В приложении могут быть не реализованы некоторые моменты (например: понятные индивидуальные ошибки при добавлении и
изменении авторов, книг и читателей) или реализованы неправильно, или глупо. Это связано с тем, что это тестовое
задание, а расписывать каждую деталь занимает много времени и моим небольшим опытом, при котором часто приходилось
обращаться к документации или к интернету.❗

При разработке приложения были использованы технологии:
`FastAPI`; `Pydantic`; `JWT`; `FastAPI_Filter`; `SQLAlchemy`; `PostgreSQL`; `Alembic`; `PyTest`; `Docker`; `Git`.
